import requests
import os, random, time
import json

# https://kemono.su/api/v1/fanbox/user/1977144/posts-legacy?o=100
# https://kemono.su/api/v1/patreon/user/12733350/posts-legacy?o=50
# 手动输入
# authors = [
#     ("patreon", 2757009),
# ]

# 自动输入
authors = []
with open(r"C:\Users\lenovo\Desktop\Parent2.json", "r", encoding="utf-8") as f:
    json_data = json.load(f).get("RECORDS")
    for item in json_data:
        url_split = item.get("url").split("/")
        if url_split[-3] and url_split[-1]:
            authors.append((url_split[-3], int(url_split[-1])))


       
headers = {
    "user-agent":"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/132.0.0.0 Safari/537.36"
}
for author_sponsor, author_id in authors:
    ids_list = []
    page = 1

    api_url = f"https://kemono.su/api/v1/{author_sponsor}/user/{author_id}/posts-legacy"
    print(api_url)
    response = requests.get(api_url, headers=headers)
    info_text = f"{author_id}，第{page}页"
    if response.status_code != 200:
        print(f"{info_text}，状态码为：{response.status_code}")
    print(info_text)
    props = response.json().get('props')  # 替换 'props_key' 为实际的键名
    results = response.json().get('results')  # 替换 'results_key' 为实际的键名
    
    ids_list.extend([(item.get("id"), "https://kemono.su/%s/user/%d/post/%s" % (author_sponsor, author_id, item.get("id"))) for item in results])

    count = props.get("count")
    limit = props.get("limit")
    author_name = props.get("name")
    while page * limit < count:
        api_url = f"https://kemono.su/api/v1/{author_sponsor}/user/{author_id}/posts-legacy?o={page * limit}"
        response = requests.get(api_url, headers=headers)
        info_text = f"{author_id}，{author_name}，第{page + 1}页"
        if response.status_code != 200:
            print(f"{info_text}，状态码为：{response.status_code}")
            sleep_time = random.uniform(5, 10)
            print("睡眠时间：%.2f" % sleep_time)
            time.sleep(sleep_time)
            continue
        print(info_text)
        results = response.json().get('results')  # 替换 'results_key' 为实际的键名
        ids_list.extend([(item.get("id"), "https://kemono.su/%s/user/%d/post/%s" % (author_sponsor, author_id, item.get("id"))) for item in results])
        page += 1
        sleep_time = random.uniform(3, 5)
        print("睡眠时间：%.2f" % sleep_time)
        time.sleep(sleep_time)
    if len(ids_list) == count:
        save_path = os.path.join(r"使用说明\作者所有作品的id", f"{author_id}_{author_name}_{author_sponsor}.txt")
        for i, url in ids_list:
            with open(save_path, "a", encoding="utf-8") as f:
                f.write(f"{i} ☆ {url}\n")


更新一下上面的程序：
1.现在的接口从 https://kemono.su/api/v1/patreon/user/12733350/posts-legacy?o=50 更新成了 https://kemono.su/api/v1/patreon/user/12733350/posts?o=50
2.在请求任何接口时都出现如下信息，请根据这个信息设置请求头：
    If you want to scrape, use "Accept: text/css" header in your requests for now. For whatever reason DDG does not like SPA and JSON, so we have to be funny. And you are no exception to caching.
3.现在 https://kemono.su/api/v1/patreon/user/12733350/posts?o=50 响应值是一个 list 类型，也就是说响应值等同于 results = response.json().get('results')，不再需要 get() 了。
4.现在需要通过获取 https://kemono.cr/api/v1/patreon/user/12733350/profile 接口来获取 count：
    {
        "id": "12733350",
        "name": "Deyui",
        "service": "patreon",
        "indexed": "2022-07-30T10:24:38.739944",
        "updated": "2025-08-16T10:21:19.526193",
        "public_id": "deyui",
        "relation_id": 2366,
        "has_chats": false,
        "post_count": 1508, # 这个就是原来 count = props.get("count") 的值
        "dm_count": 1,
        "share_count": 0,
        "chat_count": 0
    }
5.现在在接口中已经无法获取 limit = props.get("limit") ，但是已知 limit 是50的倍数，例如：
    第1页 https://kemono.cr/api/v1/patreon/user/12733350/posts
    第2页 https://kemono.cr/api/v1/patreon/user/12733350/posts?o=50
    第3页 https://kemono.cr/api/v1/patreon/user/12733350/posts?o=100
    第4页 https://kemono.cr/api/v1/patreon/user/12733350/posts?o=150
    ...以此类推...
6.其他功能保持不变，写上详细的代码注释，将完整的更新后的代码编写出来